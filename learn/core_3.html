<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes">

    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,600,600italic,700,800' rel='stylesheet' type='text/css'>

    <title>Layout</title>
    <link rel="stylesheet" media="screen" href="../assets/application-b003a2aed8000d18718b8545a3dbc91e74d9f512bac311de02fa9f621d546951.css" />
    <script src="../assets/vendor/modernizr-8560f87d0bc4f137917740acabfc72f0d469565340a978cb6aad12c44b48093a.js"></script>
    <script src="../assets/application-c98d44f2579d90a5543247901b7a56dd26df31b9e3ef0b7b90fb5f5eb9e19ef1.js"></script>
    <meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="2MC3iAcztVNkwQJD/gRox8e1YpuSJBdvIHsFdUyGIuLSs5KBeLp7+wvHrvNmljrMEqM24bX7z7ghRQVxVyhSnA==" />
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicons/favicon-8fd1ebdc0c613f27ab56adbf5ff477d2a03907ac77e43aa7679cda4a11ac6cd8.ico" />
  </head>
  <body>

    <div class="bar-container ">

  <div class="row ">
    <div class="small-12 small-centered columns">

      <nav class="top-bar " data-topbar role="navigation">

        <ul class="title-area">
          <li class="name top-bar-icon-link">
              <a href="../index.html">
                <i class="fi-home home-icon"></i>
</a>          </li>
          <li class="toggle-topbar menu-icon"><a href="core_3.html#"><span></span></a></li>
        </ul>

        <section class="top-bar-section">

            

<ul class="right header-right">


</ul>


          <!-- Buttons right of the search bar should be added to this button group -->
<ul class="left">


      <li class="normal-link ">
        <a href="../index.html">LAYOUT</a>
      </li>






</ul>

        </section>

      </nav>


    </div>
  </div>

</div>


      <script src="../assets/course_page-28737d57aa1857fe96c212a126d98314b40666074355b149d51848a75b2b837e.js"></script>
  <script src="../assets/offline_tools-cd84d6c5d61ed136223b4a93a34abde5fcbf41d4e79f732e58bd339889f84cfa.js"></script>
  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <div class="row row-padding-top" data-equalizer>

  

    <div class="medium-3 columns hide-for-small sidebar" data-equalizer-watch>
      <div class="sidebar-content">
        <div class="open active">
          <div class="spacer"></div>
            <h4>
    Lesson 3
    <a href="../index.html" class="right hidden-at-top detail">Back to menu</a>
</h4>
<hr>
<ul>
  <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-blueprint-communication">Blueprint Communication</a></li>
  <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-player-interaction">Player Interaction</a>
    <ul>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-make-a-player">Make a Player</a></li>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-game-mode-setup">Game Mode Setup</a></li>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-using-tracing-in-blueprint">Using Tracing in Blueprint</a></li>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-make-a-reticle">Make a Reticle</a></li>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-input-bindings">Input Bindings</a></li>
    </ul>
  </li>
  <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-exploding-target">Exploding Target</a>
    <ul>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-interacting-with-the-target">Interacting With The Target</a></li>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-scoring">Scoring</a></li>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-displaying-your-score">Displaying Your Score</a></li>
    </ul>
  </li>
  <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-color-changing-target">Color Changing Target</a>
    <ul>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-blueprint-interfaces">Blueprint Interfaces</a></li>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-using-our-bpi">Using our BPI</a></li>
    </ul>
  </li>
  <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-pop-up-target">Pop Up Target</a>
    <ul>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-pop-up-continuously">Pop Up Continuously</a></li>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-creating-a-new-curve">Creating a New Curve</a></li>
    </ul>
  </li>
  <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-wild-target">Wild Target</a>
    <ul>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-matinee">Matinee</a></li>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-triggering-our-matinee">Triggering our Matinee</a></li>
    </ul>
  </li>
  <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-conclusion">Conclusion</a></li>
  <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-getting-creative">Getting Creative</a>
    <ul>
      <li><div class="section-progress-container">
  <div class="section-progress"></div>
</div>
<a href="core_3.html#3-have-fun">Have Fun</a></li>
    </ul>
  </li>
</ul>

        </div>
      </div>
    </div>

    <div class="small-12 medium-9 columns" data-equalizer-watch>
      <div class="row collapse">
        <div class="small-12 small-centered columns">
  <div class="default-panel margin-bottom shadow">

   <div class="header shadow-down more-padding">
      <h4>Lesson 3 - Blueprint Communication</h4>
    </div>
    <div class="content more-padding light-background reader">
      <div id="3-blueprint-communication" class="scrollspy-section">
  <h1 class="hide" id="blueprint-communication">Blueprint Communication</h1>

  <blockquote class="challenge">
    <h3 id="download-the-starter-project">Download the Starter Project</h3>
    <p>Layout uses one Master Starter Project. If you’ve downloaded it recently, chances are you don’t need to re-download it.</p>

    <p><em>This tutorial requires that you’ve downloaded the starter project as of 4/7/16</em>:</p>

    <ul>
      <li><a href="https://github.com/LayoutVR/ToyBoxx/archive/master.zip" class="blue"><strong>Click here</strong></a> to download the Layout Master starter project.</li>
      <li>Extract the zip folder.</li>
      <li>Open up the <strong>Layout_ToyBoxx.uproject</strong> and <em>begin your adventure</em>!</li>
    </ul>
  </blockquote>

  <p>In our previous lesson, we learned how to create Blueprint actors with interesting behavior. In this lesson, we will allow the player to interact with objects in the level using simple blueprint communication paradigms. We’ll do this by creating a shooting gallery, similar one you might find in an arcade.</p>

  <p>The shooting gallery we will create is a good introduction to <strong>blueprint interface design</strong> in Unreal Engine. As we learn more about creating experiences, it will become increasingly important that our blueprints communicate sensibly. Blueprints can get complicated quickly if we aren’t careful.</p>

  <p>Some of the assets and interactions will be provided, but you will be making most assets yourself, most notably the different types of targets. Here’s a preview of what you’ll be making:</p>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/shooting_gallery_finished.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>Let’s break the experience down into the pieces that we’ll be making together.</p>

  <ul>
    <li>Basic Target
      <ul>
        <li>Explodes and disappears when shot, awarding points.</li>
      </ul>
    </li>
    <li>Color Changing Target
      <ul>
        <li>Explodes and disappears when shot, awarding points.</li>
        <li>Randomly changes between red, green, and gold. Each state is worth different point values.</li>
      </ul>
    </li>
    <li>Pop Up Target
      <ul>
        <li>Explodes and disappears when shot, awarding points.</li>
        <li>Continuously pops up from behind cover, then returns to hiding position.</li>
      </ul>
    </li>
    <li>Wild Target
      <ul>
        <li>Explodes when shot, awarding points. Does not disappear.</li>
        <li>Moves all over the gallery for a short period of time.</li>
      </ul>
    </li>
  </ul>

  <p>Every target on our to do list involves the player shooting it. Let’s implement a shooting mechanism for the player.</p>

  <hr />

</div>
<div id="3-player-interaction" class="scrollspy-section">
  <h2 id="player-interaction">Player Interaction</h2>

  <ul>
    <li>Open the starter level <strong>Lesson3 &gt; DesktopShootingGallery</strong>.</li>
  </ul>

  <p>This lesson will take place on the desktop surface we’ve provided.</p>

  <ul>
    <li>Make sure your HMD’s positional tracking camera is enabled and <strong>Play in VR</strong>. Take a look around.</li>
  </ul>

  <p>Notice how the world around you is scaled down. When placed in a tiny world like this, your head movements make a big difference. This is a great way to take advantage of your HMD’s translational degrees of freedom.</p>

  <p>Before we get started, let’s create a player and corresponding game mode.</p>

</div>
<div id="3-make-a-player" class="scrollspy-section sub-section">
  <h3 id="make-a-player">Make a Player</h3>

  <p>Let’s make a new <strong>Pawn</strong> Blueprint for our player.</p>

  <ul>
    <li><strong>Right-click</strong> in your <strong>Content Browser</strong></li>
    <li>Select <strong>Blueprint Class</strong> from the <em>Create Basic Asset</em> section of the menu.</li>
    <li>Select <strong>Pawn</strong> in the popup menu.</li>
  </ul>

  <blockquote class="important">
    <p>A <strong class="blueprint">Pawn</strong> is a special type of <strong class="blueprint">Actor</strong> that can be controlled by the player.</p>
  </blockquote>

  <ul>
    <li>Name your blueprint <strong>BP_InteractionPlayer</strong>.</li>
  </ul>

</div>
<div id="3-game-mode-setup" class="scrollspy-section sub-section">
  <h3 id="game-mode-setup">Game Mode Setup</h3>

  <p>Currently, our <strong class="blueprint">BP_InteractionPlayer</strong> is not the default Player Pawn that the level uses. We have to set that up before we can test our new blueprint.</p>

  <p>To do that, we have to create a new <strong>Game Mode</strong>.</p>

  <ul>
    <li><strong>Right-click</strong> in the <strong>Content Browser</strong></li>
    <li>Select <strong>Blueprint Class</strong> from the <em>Create Basic Asset</em> section of the menu</li>
    <li>Select <strong>Game Mode</strong> in the popup menu</li>
    <li>Name your Game Mode ‘ShootingGalleryGameMode’</li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/create_game_mode.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>At this point, we don’t need to open the new game mode blueprint. Instead:</p>

  <ul>
    <li>Go to your toolbar in the <strong>Level Editor</strong></li>
    <li>Select <strong>Settings &gt; World Settings</strong></li>
    <li>A new tab just opened up next to your <strong>Details</strong> panel.</li>
    <li>Click the dropdown box next to <strong>GameMode Override</strong> and select your ‘ShootingGalleryGameMode’.</li>
  </ul>

  <p>Right below, you should now be able to edit your <strong>Default Pawn Class</strong> for the <strong>Selected GameMode</strong>.</p>

  <ul>
    <li>Select your ‘BP_InteractionPlayer’ from the <strong>Default Pawn Class</strong> dropdown.</li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/set_game_mode_and_player.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>The player will now control a <strong class="blueprint">BP_InteractionPlayer</strong> when the level is started.</p>

  <ul>
    <li>Press <strong>Play</strong> to test it out</li>
  </ul>

  <p>You might notice that the pawn does not rotate with player input. At the risk of causing some simulation sickness, let’s enable rotation using a new component.</p>

  <ul>
    <li>Return to the <em class="blueprint">BP_InteractionPlayer</em> blueprint.</li>
    <li>Add a <strong>BPC Camera Control</strong> component.</li>
  </ul>

  <p><strong>BPC Camera Control</strong> simply takes input from the mouse or game pad and rotates the pawn. If you’re curious, you can pop the hood to see for yourself.</p>

</div>
<div id="3-using-tracing-in-blueprint" class="scrollspy-section sub-section">
  <h3 id="using-tracing-in-blueprint">Using Tracing in Blueprint</h3>

  <p><strong>Tracing</strong> (sometimes referred to as raycasting) is a powerful game engine technique that allows us to capture information about a level and its objects. Given an orientaion and location, a trace can determine what exists in the environment along the path it follows. Most commonly, a trace is performed along a line, but we can also trace with shapes like the box, sphere, and capsule.</p>

  <ul>
    <li>Start by placing a <em class="node">Line Trace By Channel</em> node in the event graph.</li>
  </ul>

  <blockquote class="optional">
    <p>As you type, you’ll notice a number of Trace node options appear. If you hover over each node name, an informative description will come up. If you can’t be bothered, here is a basic desription of the key differences:</p>

    <p><strong>Multi Trace</strong> vs <strong>Trace</strong>:</p>

    <ul>
      <li>A <strong>Multi Trace</strong> will output an array of <em>all</em> actors that exist along the trace path.</li>
      <li>A <strong>Trace</strong> will only output the <em>first</em> actor that exists along the trace path from the start position.</li>
    </ul>

    <p><strong>Trace by Channel vs Trace for Objects</strong>:
These options have to do with how the trace should respond to different actors. These settings can be customized in the <em>Collision</em> tab of any collide-able component.</p>

    <ul>
      <li><strong>By Channel</strong> traces use a specific <em>Trace Channel</em> and responds to actors depending on how they have their collisions set up.</li>
      <li><strong>For Objects</strong> allows you to define which <em>Collision Object Types</em> you want your trace to collide with.</li>
    </ul>
  </blockquote>

  <p>Let’s allow the player to “shoot” (execute a line trace) with left mouse button click. UE4 provides a special click event for convenience.</p>

  <ul>
    <li>Place a <b class="node event">Left Mouse Button</b> event.</li>
  </ul>

  <p>Now we need to calculate the <strong>Start</strong> and <strong>End</strong> point of our trace line:</p>

  <p>\begin{equation}
    \text{Start}
    =
  \begin{bmatrix}
  \text{Camera Location}
  \end{bmatrix}
\end{equation}</p>

  <p>\begin{equation}
    \text{End}
    =
  \begin{bmatrix}
  \text{Camera Location}
  \end{bmatrix}
  +
  \begin{bmatrix}
  \text{Camera Forward Vector}
  \end{bmatrix}
  \times
  10000
\end{equation}</p>

  <p>The <strong>Start</strong> will be the camera’s location, and the <strong>End</strong> will be some distant point in the direction that we’re looking. Here we’ve made the <strong>End</strong> point 10000cm out in front of us so we are guaranteed to hit everything around us.</p>

  <blockquote class="challenge" id="challenge-3-01-00">
    <h4 id="challenge">Challenge:</h4>
    <p>Your challenge is to implement the math above. To get the <strong>Camera Location</strong> and <strong>Camera Forward Vector</strong>, use Layout’s <b class="node ">Get Player VR Camera Properties</b> node.</p>

    <p>Using the <em class="node">Get Player VR Camera Properties</em>, <em class="node">Vector + Vector</em>, and <em class="node">Vector * Float</em> nodes, calculate <em class="variable"><i class="detail">Line Trace By Channel &gt;</i> Start <i class="pin out vector"></i></em> and <em class="variable pin-out"><i class="detail">Line Trace By Channel &gt;</i> End <i class="pin out vector"></i></em>.</p>

    <p>At this point the trace is invisible. For debugging purposes, change <b class="variable"><i class="detail">Line Trace By Channel &gt; </i> Draw Debug Type<i class="pin out enum"></i></b> to <strong>For Duration</strong>.</p>

    <p>You’ll know you’ve done everything right if you see a red square (and a red line if you’re in VR) when you click. That red square marks the location where your trace first hit an actor.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.1.png" /></p>
  </blockquote>

  <blockquote class="important">
    <h4 id="gaze-based-interation-and-vr">Gaze based interation and VR</h4>
    <p>Virtual reality requires developers to think differently about interaction design. We sacrifice the convenience of outmoded UI solutions to realize the opportunity of stereoscopic immersion.</p>

    <p>The headset provides information about the user’s gaze in the virtual environment. With this information, we can interact with objects in the world intuitively and with little to no peripheral hardware input. We call this interaction model <strong>gaze based interaction</strong>.</p>
  </blockquote>

  <p>Now that we have a line trace successfully shooting from our eyes when we click, let’s do something with it.</p>

  <p>Traces have two outputs:</p>

  <ul>
    <li>An <b class="variable">Out Hit<i class="pin out struct"></i></b> structure containing information about what was hit and at what location in the world.</li>
    <li>A <b class="variable">Return Value<i class="pin out bool"></i></b> boolean, which tells you whether or not anything was hit at all.</li>
  </ul>

  <blockquote class="optional">
    <p>Remember from the <a href="variables.html" class="blue" target="_blank">variables lesson</a>, <b class="variable"><i class="pin out bool"></i>Boolean</b> values are either <strong>True</strong> or <strong>False</strong>.</p>
  </blockquote>

  <p>Let’s start by printing out the name of the actor that the trace hits. We only want to print a string if anything was hit at all. We can do this using the <b class="variable"><i class="detail">Line Trace By Channel &gt;</i> Return Value<i class="pin out bool"></i></b> and a <b class="node gray">Branch</b>.</p>

  <ul>
    <li>Place a <b class="node gray">Branch</b></li>
    <li><b class="node">Line Trace By Channel<i class="pin execution out"></i></b><span class="connector execution"></span><b class="node gray"><i class="pin execution in"></i>Branch</b></li>
    <li><b class="variable">Return Value<i class="pin out connected bool"></i></b><span class="connector bool"></span><b class="variable"><i class="pin in connected bool"></i>Condition</b></li>
  </ul>

  <p><img alt="Line Trace to Branch" class="zoomable" src="../assets/learn_resources/core_3/3.4.png" /></p>

  <p>A <em class="node gray">Branch</em> works by checking a boolean condition and then directing the code down different paths depending on its value. You’ll notice the node has two execution outputs, one labeled <strong>True</strong> and another labeled <strong>False</strong>. This is how we can add logic to our code, executing specific code depending on certain conditions.</p>

  <blockquote>
    <p>If you’re familiar with programming, a <em class="node gray">Branch</em> node is an <strong>if statement</strong>.</p>
  </blockquote>

  <p>Right now, we only care about when the line trace hits something (i.e. the <strong>True</strong> output).</p>

  <ul>
    <li>Place a <strong class="node">Print String</strong></li>
    <li><b class="node gray"><i class="detail">Branch &gt; </i>True<i class="pin execution out"></i></b><span class="connector execution"></span><b class="node "><i class="pin execution in"></i>Print String</b></li>
  </ul>

  <p>Now we just have to get the name of the actor our trace hit. To do that, we need to use the trace’s <b class="variable">Out Hit<i class="pin out struct"></i></b> information.</p>

  <ul>
    <li>Pull a wire out of <b class="variable">Out Hit<i class="pin out struct"></i></b> and place a <b class="node green">Break Hit Result</b>.</li>
  </ul>

  <p>The <em class="node green">Break Hit Result</em> node breaks the <b class="variable">Out Hit<i class="pin out struct"></i></b> structure into all the different information it contains. Look at all that info!</p>

  <ul>
    <li><b class="variable">Hit Actor<i class="pin out connected object"></i></b><span class="connector object-to-string"></span><b class="variable"><i class="pin in connected string"></i>In String</b> (UE4 will automatically place an intermediary <b class="node green"><i class="pin in object"></i>Get Display Name<i class="pin out string"></i></b>)</li>
  </ul>

  <p><img alt="Print traced object name" class="zoomable" src="../assets/learn_resources/core_3/3.5.png" /></p>

  <p>Test it out! You’ll see the printed name of whatever actor you click on.</p>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/print_actor_name.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <h4 id="interacting-with-other-actors">Interacting With Other Actors</h4>

  <p>Now that we have a reference to other actors thanks to our <strong>Trace</strong>, we can easily fire their events and call their functions. This is how we “communicate” between blueprints.</p>

  <p>Layout has provided the <em class="blueprint">BP_InteractionTest</em> to get going as fast as possible! The <em class="blueprint">BP_InteractionTest</em> blueprint has a custom event called <em class="node event">Interact</em>. Whenever the <em class="node event">Interact</em> event is fired, the cube will change colors.</p>

  <p>In order to fire the <em class="node event">Interact</em> event from our player, we first need to make sure that the actor we traced is in fact a <em class="blueprint">BP_InteractionTest</em>. We do that using a <em class="node">Cast To…</em> node.</p>

  <ul>
    <li>Replace the <em class="node">Print String</em> node with a <em class="node">Cast to BP_InteractionTest</em> node.</li>
    <li>Pull a wire out of the <em class="variable object">As BP_InteractionTest<i class="pin object"></i></em> output and place the blueprint’s <em class="node">Interact</em> node.</li>
    <li><b class="node">Cast to BP_InteractionTest<i class="pin execution out"></i></b><span class="connector execution"></span><b class="node"><i class="pin execution in"></i>Interact</b></li>
  </ul>

  <p><img alt="Cast to BP_InteractionTest" class="zoomable" src="../assets/learn_resources/core_3/3.7.png" /></p>

  <p>By successfully casting the <b class="variable">Hit Actor<i class="pin out object"></i></b> to a <b class="variable">BP_InteractionTest<i class="pin out object"></i></b>, we were able to call the <em class="node">Interact</em> event only available to the <em class="blueprint">BP_InteractionTest</em>.</p>

  <blockquote class="optional hide">
    <p><a href="core_3.html" class="blue"><strong>Click here</strong></a> if you want to dive deep into what <strong>Casting</strong> is and how it works. <span class="hide">[TODO: more info on casting. What we’re actually doing. Why we need to cast to call Interact]</span></p>
  </blockquote>

  <p>Go ahead and test it out. You should be able to look at a <em class="blueprint">BP_InteractTest</em> in the world and make it change colors when you click.</p>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/interaction_test.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

</div>
<div id="3-make-a-reticle" class="scrollspy-section sub-section">
  <h3 id="make-a-reticle">Make a Reticle</h3>

  <p>Without a reticle, you may have some difficulty targeting actors in the level. Create a VR friendly reticle following the steps in the challenge below.</p>

  <p>It’s important to understand the reasoning behind our solution. In a monoscopic (non-VR) experience, we can draw a reticle in <strong>screen space</strong>. Screen space is the two dimensional coordinate system defined by the width and height of the screen. Stereoscopically, a screen space reticle cannot be viewed correctly at depth in each eye.</p>

  <p>The best way to fix this issue is to use a <strong>Line Trace</strong> and project the reticle out into the world. In this way, our reticle is similar to a laser pointer, resting on the actual object we’re looking at.</p>

  <p>To start, let’s create the component what will act as a reticle out in the world:</p>

  <ul>
    <li>Add a <strong>Material Billboard</strong> component to <strong class="blueprint">BP_InteractionPlayer</strong>.
      <ul>
        <li>Give it a new Sprite by clicking the <strong>+</strong> next to <strong>Sprite &gt; Elements</strong></li>
        <li>Use the <strong>M_Reticle</strong> material</li>
        <li>Check the <strong>Size Is In Screen Space</strong> option</li>
        <li>Set <strong>Base Size X: 0.008</strong></li>
        <li>Set <strong>Base Size Y: 0.008</strong></li>
      </ul>
    </li>
  </ul>

  <p><img alt="Material Billboard Details" class="not-zoomable small" src="../assets/learn_resources/core_3/reticle_material_billboard.png" /></p>

  <p>Great! You just added the circular reticle to the player. The options we set up ensure that the reticle always appears the same size, no matter how close or far it is from the player. Also, the <strong>M_Reticle</strong> material is set up to always draw on top, meaning it will never disappear behind other objects.</p>

  <p>At this point, you won’t be able to see the reticle when you press Play. This is because we still have to project it out into the world like a laser dot coming from a laser pointer.</p>

  <blockquote class="challenge" id="challenge-3-02-01">
    <h4 id="challenge-1">Challenge:</h4>
    <p>Project the <strong>Material Billboard</strong> reticle out into the world by updating its location every frame (<b class="node event">Tick</b>).</p>

    <p>Use a <b class="node ">Line Trace by Channel</b> pointing straight from the player’s eyes to determine the proper location for the reticle. Make sure to <b class="node green">Break Hit Result</b> to get the proper location.</p>

    <p>To update a component’s location like your <strong>Material Billboard</strong>, drag out a reference to the component and use the <b class="node ">Set World Location</b> node.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/finished_reticle_challenge.png" /></p>
  </blockquote>

  <p>Q: “Why don’t I just attach a billboard to my camera and place it way out in front of my player?”</p>

  <p>A: Moving the reticle into world space at a fixed distance from the player works, however it often has strange side effects in VR. Imagine looking at a wall in front of you, yet your reticle appears to be way far behind it. Since we can perceive depth in stereoscopic 3D, having a reticle at a fixed position is not ideal. With our implementation, we allow the viewer to see the reticle and the object it touches simultaneously without changing focus.</p>

  <p>Unfortunately, there is one bug with our implementation right now. If you ever look out into the distance to a point where the trace does not hit anything, the reticle remains where is was last. Here’s what it looks like:</p>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/reticle_bug.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <blockquote class="challenge">
    <h4 id="challenge-2">Challenge:</h4>
    <p><strong>Fix the bug!</strong> When the <b class="node ">Line Trace by Channel</b> does not hit anything, position the <strong>Material Billboard</strong> some set distance in front of the camera.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/finished_reticle_bug_challenge.png" /></p>
  </blockquote>

  <blockquote class="optional">
    <p>In the challenge image above, you may have noticed a vector wire being redirected around a node. This is accomplished with a <strong>Reroute Node</strong> which has no purpose other than making a graph more legible.</p>
  </blockquote>

  <p>OK! You should now have a fully functional reticle. This will make interacting with the world so much easier!</p>

</div>
<div id="3-input-bindings" class="scrollspy-section sub-section">
  <h3 id="input-bindings">Input Bindings</h3>

  <p>Currently, in our <em class="blueprint">BP_InteractionPlayer</em> blueprint we use the <em class="node event">Left Mouse Button</em> event to trigger our <strong>Trace</strong>. This is fully functional, but can also be improved using <strong>Input Bindings</strong>!</p>

  <p><strong>Input Bindings</strong> allow us to associate multiple inputs to one event. In that way, we can have the <strong>Space Bar</strong>, <strong>Left Mouse Button</strong>, and a <strong>Gamepad Button</strong> all fire the same player event. <strong>Input Bindings</strong> also make it easier to change keybindings, for ourselves and our users.</p>

  <ul>
    <li>Open the <strong>Settings</strong> menu from the Level Editor <strong>Toolbar</strong>.</li>
    <li>Select <strong>Project Settings</strong></li>
    <li>Go to the <strong>Input</strong> page using the left sidebar.</li>
  </ul>

  <p>There under the <strong>Bindings</strong> tab you’ll see <strong>Action Mappings</strong> and <strong>Axis Mappings</strong>. Layout’s Starter Project has some mappings already created, but you’ll need to add a new one for this lesson.</p>

  <p><img alt="Input Mappings" class="zoomable" src="../assets/learn_resources/core_3/input_mappings.png" /></p>

  <blockquote class="important">
    <p><strong>Action Mappings</strong> are for single input actions like a key press.</p>

    <p><strong>Axis Mappings</strong> are for input that change over time like joystick and mouse movement.</p>
  </blockquote>

  <p>We want to bind clicks and button presses. Which type of mapping do we want to make?</p>

  <ul>
    <li>Click the <strong>+</strong> next to <strong>Action Mappings</strong></li>
  </ul>

  <p>A submenu should open up, allowing you to name a new Action and map new inputs to it.</p>

  <ul>
    <li>Name the Action <strong>Act</strong>.</li>
    <li>Bind a <strong>Left Mouse Button</strong> input to the <strong>Act</strong> action.</li>
    <li>Click the <strong>+</strong> next to the <strong>Act</strong> action twice to bind two more inputs.</li>
    <li>Bind a <strong>Space Bar</strong> input.</li>
    <li>Bind a <strong>Gamepad Face Button Bottom</strong> input.</li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/add_input.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>The <em class="node event">Act</em> input event will now be fired whenever the player Left Clicks, presses Space Bar, or presses the Bottom Face Button on a gamepad (A on an Xbox controller or X on a Playstation controller). Let’s use the <em class="node event">Act</em> event rather than the <em class="node event">Left Mouse Button</em> event in our <strong>player blueprint</strong>.</p>

  <ul>
    <li>Open <em class="blueprint">BP_InteractionPlayer</em></li>
    <li>Replace <em class="node event">Left Mouse Button</em> event with the new <em class="node event">Act</em> event.</li>
  </ul>

  <p><img alt="Using the Act input action" class="zoomable" src="../assets/learn_resources/core_3/3.9.png" /></p>

  <p>Test it out! All the bound inputs should fire this event.</p>

  <hr />

</div>
<div id="3-exploding-target" class="scrollspy-section">
  <h2 id="exploding-target">Exploding Target</h2>

  <p>Time to create the first, most basic target:</p>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/exploding_target_finished.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>Layout has already provided a target blueprint called <em class="blueprint">BP_Target</em>. Open it and you will see that it is just a scaled down static mesh. It currently doesn’t do anything special with its empty event graph.</p>

  <blockquote class="optional">
    <p>Remember, we’re working with a tiny world in this lesson to play with the effects of scale. That’s why the demo target and everything other static mesh is scaled down to about one-tenth size.</p>
  </blockquote>

  <p>Let’s edit this blueprint to explode when it is interacted with.</p>

</div>
<div id="3-interacting-with-the-target" class="scrollspy-section sub-section">
  <h3 id="interacting-with-the-target">Interacting With The Target</h3>

  <ul>
    <li>Open <em class="blueprint">BP_Target</em>’s Event Graph.</li>
    <li>Right-click in the Event Graph and search <strong>Add Custom Event…</strong>.</li>
    <li>Place the new event node and name it <strong>Interact</strong></li>
  </ul>

  <p>Since we just added a new event that we want to fire from other places, we need to force UE4 to <strong>Compile</strong> the new changes.</p>

  <ul>
    <li>Click the <strong>Compile</strong> button in the upper left section of the Blueprint Toolbar.</li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/add_custom_event.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <blockquote class="important">
    <p>If you ever run into strange engine behavior when writing code, make sure to try the <strong>Compile</strong> button on the appropriate assets.</p>
  </blockquote>

  <p>For now, let’s print a string when the target’s <em class="node event">Interact</em> event is fired.</p>

  <ul>
    <li><b class="node event">Interact<i class="pin execution out"></i></b><span class="connector execution"></span><b class="node"><i class="pin execution in"></i>Print String</b></li>
  </ul>

  <p><img alt="Print Interact" class="zoomable" src="../assets/learn_resources/core_3/target_print_interact.png" /></p>

  <p>This way, we can test that our player is properly firing the target’s <b class="node event">Interact</b> event. Once we have the interaction working, we can customize how the target actually behaves.</p>

  <ul>
    <li>Place a <em class="blueprint">BP_Target</em> in the world.</li>
  </ul>

  <p><img alt="target in world" class="zoomable" src="../assets/learn_resources/core_3/target_in_world.png" /></p>

  <p>Before we can interact with our target, we have to setup our player to fire the <em class="blueprint">BP_Target</em>’s <b class="node event">Interact</b> event.</p>

  <ul>
    <li>Open <em class="blueprint">BP_InteractionPlayer</em></li>
    <li>Place a <em class="node">Cast to BP_Target</em> node</li>
    <li><b class="node "><i class="detail">Cast To BP_InteractionTest &gt; </i>Cast Failed<i class="pin execution out"></i></b><span class="connector execution"></span><b class="node"><i class="pin execution in"></i>Cast To BP_Target</b></li>
    <li><b class="variable"><i class="detail">Break Hit Result &gt; </i>Hit Actor<i class="pin out connected object"></i></b><span class="connector object"></span><b class="variable"><i class="pin in connected object"></i><i class="detail">Cast to BP_Target &gt; </i>Object</b></li>
    <li>Pull a wire out of <b class="variable"><i class="detail">Cast to BP_Target &gt; </i>As BP_Target<i class="pin out object"></i></b> and place an <em class="node">Interact <i class="detail">(BP_Target)</i></em> node.</li>
    <li><b class="node ">Cast To BP_Target<i class="pin execution out"></i></b><span class="connector execution"></span><b class="node "><i class="pin execution in"></i>Interact</b></li>
  </ul>

  <p><img alt="Interact with BP_InteractionTest and BP_Target using Casts" class="zoomable" src="../assets/learn_resources/core_3/3.60.png" /></p>

  <p>Here we are attempting a chain of <strong>Casts</strong>. Essentially, we first check if the actor we traced is a <em class="blueprint">BP_InteractionTest</em>. If it is, we fire that actor’s specific <em class="node">Interact <i class="detail">(BP_InteractionTest)</i></em> event. If it is not, the cast fails and we then check if the actor is a <em class="blueprint">BP_Target</em>, calling its specific <em class="node">Interact <i class="detail">(BP_Target)</i></em> event.</p>

  <blockquote class="important">
    <p>Even though the <em class="blueprint">BP_InteractionTest</em> and <em class="blueprint">BP_Target</em> both have events called <strong>Interact</strong>, they are completely independent of each other. We name them both <strong>Interact</strong> because that generalizes what <em class="blueprint">BP_InteractionPlayer</em> does. What’s important is that <em class="blueprint">BP_InteractionTest</em> and <em class="blueprint">BP_Target</em> both handle what they do once they are interacted with. In this way, <em class="blueprint">BP_InteractionPlayer</em> just has to <em class="node">Interact</em> with objects.</p>

    <p>This concept helps us when we program, allowing us to think about each object individually and not about how each object interacts with everything else.</p>

    <p>We’ll talk more about this powerful programming concept later on in this lesson.</p>
  </blockquote>

  <p>Go ahead and test it out! Whenever you click on a <em class="blueprint">BP_Target</em> you should see your string print to the screen.</p>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/interact_with_target.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>Now let’s program the <b class="blueprint">BP_Target</b> to actually do something!</p>

  <blockquote class="challenge" id="challenge-3-02-01">
    <h4 id="challenge-3">Challenge:</h4>
    <p>Make the <b class="blueprint">BP_Target</b>’s <b class="node event">Interact</b> event spawn a <strong>P_NeonExplosion_Tiny</strong> emitter and destroy the <b class="blueprint">BP_Target</b> actor.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.51.png" /></p>
  </blockquote>

  <blockquote class="optional">
    <p>Notice how we have to use the <em>tiny</em> version of our particle emitter. We can scale down the size of an emitter, but that won’t effect the velocities the particles move at. When we build worlds at small scale, we also have to consider that everything must move at lower velocities too.</p>

    <p>In the next lesson, we’ll go over a great way to keep everything normal scale while still making the world feel small.</p>
  </blockquote>

</div>
<div id="3-scoring" class="scrollspy-section sub-section">
  <h3 id="scoring">Scoring</h3>

  <p>How are we going to pwn noobs at the shooting gallery if we can’t keep track of our high scores? Let’s build a script that will store a score that is displayed in the level.</p>

  <p>As you might remember from our previous lesson, we store data in <strong>Variables</strong>. Because our score is a whole number, we’ll use an <b class="variable"><i class="pin bar int"></i>Integer</b> variable.</p>

  <blockquote class="important">
    <p><a href="variables.html" class="blue" target="_blank"><strong>Click here</strong></a> to learn about variables and their types if this is unfamiliar to you.</p>
  </blockquote>

  <ul>
    <li>Open <em class="blueprint">BP_InteractionPlayer</em></li>
    <li>Click the small <strong>+</strong> icon next to the <strong>Variables</strong> tab in the <strong>My Blueprint</strong> panel.</li>
    <li>Name the variable <strong>Score</strong></li>
  </ul>

  <p>You’ll notice that the icon next to the name of the variable is red. This means it is a <b class="variable"><i class="pin bar bool"></i>Boolean</b> variable. We want to change it to an <b class="variable"><i class="pin bar int"></i>Integer</b> variable.</p>

  <ul>
    <li>With the variable selected, go to the <strong>Details</strong> panel and open the <strong>Variable Type</strong> dropdown.</li>
    <li>Select <strong>Integer</strong>.</li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/misc/create_variable.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>Now we need to update the score whenever we hit a target. Every time we hit a target, we need to add 1 to our score.</p>

  <blockquote class="challenge" id="challenge-3-03-00">
    <h4 id="challenge-4">Challenge:</h4>
    <p>Using a <b class="node ">Set Score</b>, a <strong class="node">Get Score</strong>, and an <strong class="node">Integer + Integer</strong> node, write code to add <strong>1</strong> to the player’s score every time they hit (interact) a target.</p>

    <p>Use a <strong class="node">Print String</strong> node to print the value of <strong class="variable">Score <i class="pin int"></i></strong> to test that it’s working.</p>

    <p><em>A similar scenario is covered in the <a href="variables.html" class="blue" target="_blank"><strong>variables lesson</strong></a> if this is proving difficult.</em></p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.62.png" /></p>
  </blockquote>

</div>
<div id="3-displaying-your-score" class="scrollspy-section sub-section">
  <h3 id="displaying-your-score">Displaying Your Score</h3>

  <p>We’re ready to display our score to the user. We could draw the score in <strong>screen space</strong>. This is an effective approach in monoscopic experiences used by many developers. Unfortunately, this solution is <strong>never</strong> appropriate for virtual reality. Information drawn directly “on” the screen cannot be seen properly at depth by both eyes.</p>

  <p>Beacuse we can’t draw our score directly on the screen, we need to display the information somewhere in three dimensional space. There are two basic categories of three dimensional UI for VR: <strong>player relative</strong> and <strong>world relative</strong>.</p>

  <p><strong>Player relative</strong> interfaces are attached to the player as they move through the environment. A <strong>heads up display</strong> or <strong>HUD</strong> is a good example of a player relative interface. This strategy can be effective in VR, but there are significant challenges to displaying this information in a way that is comfortable and intuitive. Player relative UIs are most successful when they are either grounded in a cockpit or not persistent.</p>

  <p><strong>World relative</strong> interfaces are displayed in the environment and detached from the player. These UI elements are usually static and positioned in relation to other elements in the scene. This strategy is the least obtrusive, easiest to implement, and most similar to real life. Whenever possible, we recommend you use this technique.</p>

  <p>Let’s create a world relative score element now.</p>

  <ul>
    <li>Create an Actor Blueprint named <strong class="blueprint">BP_Scoreboard</strong>.</li>
    <li>Add a <strong>Text Render</strong> component.
      <ul>
        <li>Set <strong>Text</strong> to “<strong>0</strong>”</li>
        <li>Change its <strong>Text Render Color</strong>, <strong>Alignment</strong>, and <strong>World Size</strong> as desired</li>
        <li>If you want your text to always be visible and not depend on lighting, set <strong>Text Material</strong> to <strong>M_EmissiveText</strong>. We talk more about this in Lesson 5.</li>
      </ul>
    </li>
  </ul>

  <p>We now have a simple scoreboard that displays text in the world using a <strong>Text Render</strong> component. Let’s add a new event that updates the score. We want this event to take an input value of the new score that the scoreboard should display. This way our <b class="blueprint">BP_InteractionPlayer</b> can update the scoreboard and tell it what the score is.</p>

  <ul>
    <li>Add a new custom event called <strong class="node event">UpdateScore</strong>.</li>
    <li>In the <strong>Details</strong> panel click <strong>New</strong> in the <strong>Inputs</strong> tab</li>
    <li>Rename the <em>NewParam</em> to <strong>Score</strong></li>
    <li>Set the input’s type to <b class="variable"><i class="pin bar int"></i>Integer</b></li>
    <li><strong>Compile</strong></li>
  </ul>

  <p><img alt="UpdateScore event" class="zoomable" src="../assets/learn_resources/core_3/3.63.png" /></p>

  <p>Now when we fire <strong class="node event">UpdateScore</strong> it will have a <strong class="variable"><i class="pin in int"></i>Score</strong> input. It’s up to <strong class="blueprint">BP_Scoreboard</strong> to update the displayed score. Let’s do that.</p>

  <ul>
    <li>Right-click and search for <strong class="node">Set Text (TextRender)</strong></li>
    <li><b class="variable"><i class="detail">UpdateScore &gt; </i>Score<i class="pin out connected int"></i></b><span class="connector int-to-string"></span><b class="variable"><i class="pin in connected string"></i><i class="detail">Set Text &gt; </i>Value</b>. UE4 will place an intermediary integer to text conversion node.</li>
  </ul>

  <p><img alt="Finished UpdateScore" class="zoomable" src="../assets/learn_resources/core_3/3.64.png" /></p>

  <ul>
    <li>Place a <b class="blueprint">BP_Scoreboard</b> in the world where the player can see it.</li>
  </ul>

  <p>Great! <strong class="blueprint">BP_Scoreboard</strong> is finished, now we just need to call <strong class="node">UpdateScore</strong> from the player blueprint whenever we hit a target.</p>

  <ul>
    <li>Open <strong class="blueprint">BP_InteractionPlayer</strong>.</li>
  </ul>

  <p>The problem here is that we need a reference to the <strong class="blueprint">BP_Scoreboard</strong> in order to fire the <strong class="node event">UpdateScore</strong> event. Fortunately there is a node that will get all the BP_Scoreboards in the level. Since we just have one scoreboard, we can find it easily this way. The node is called <strong class="node">Get All Actors Of Class</strong>.</p>

  <blockquote class="important">
    <p><strong class="node">Get All Actors Of Class</strong> is an expensive operation, meaning that if you use it a lot, your experience will run slow and have bad performance. Avoid using it consistently while the game is running.</p>
  </blockquote>

  <ul>
    <li>Place a <strong class="node">Get All Actors Of Class</strong> node.</li>
    <li>Select <strong>BP_Scoreboard</strong> from the <strong class="variable"><i class="pin class"></i>Actor Class</strong> dropdown.</li>
  </ul>

  <p>Since we don’t want to use <strong class="node">Get All Actors Of Class</strong> every single time we hit a target, let’s use it only once when the game starts, then store the reference to the scoreboard in a variable.</p>

  <ul>
    <li>Create a new variable named <strong>Scoreboard</strong>.
      <ul>
        <li>Search “BP_Scoreboard” for it’s <em>*Variable Type</em></li>
        <li>Set its type to <strong class="variable"><i class="pin bar object"></i>BP_Scoreboard &gt; Reference</strong>.</li>
      </ul>
    </li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/create_scoreboard_variable.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>Now we have a variable that can hold a reference to a <b class="variable"><i class="pin in object"></i>BP_Scoreboard</b> actor. Let’s get the correct scoreboard and set this variable when the game starts:</p>

  <ul>
    <li><b class="node event">BeginPlay<i class="pin execution out"></i></b><span class="connector execution"></span><b class="node "><i class="pin execution in"></i>Get All Actors Of Class</b></li>
  </ul>

  <p><strong class="node">Get All Actors Of Class</strong> outputs an array of actors. This is helpful if there are many actors of that type, but we know there is only one <strong class="blueprint">BP_Scoreboard</strong> in our level. Let’s get the first actor from the <strong class="variable">Out Actors<i class="pin array object"></i></strong> array.</p>

  <ul>
    <li>Pull a wire from the <strong class="variable">Out Actors<i class="pin array object"></i></strong> and place a <strong class="node">Get</strong> node.</li>
    <li>Pull a wire from the <strong class="node">Get <i class="pin object"></i></strong> output (this is your <b class="blueprint">BP_Scoreboard</b>) and place a <strong class="node">Set Scoreboard</strong> node.</li>
    <li><b class="node">Get All Actors Of Class<i class="pin execution out"></i></b><span class="connector execution"></span><b class="node"><i class="pin execution in"></i>Set Scoreboard</b></li>
  </ul>

  <p><img alt="Use Get All Actors of Class to store the BP_Scoreboard" class="zoomable" src="../assets/learn_resources/core_3/3.65.png" /></p>

  <p>We now will always have a reference to the scoreboard in the world. Let’s use it to update the score whenever we hit a target.</p>

  <blockquote class="challenge" id="challenge-3-04-00">
    <h4 id="challenge-5">Challenge:</h4>
    <p>Use the <b class="variable"><i class="pin bar object"></i>Scoreboard</b> variable and its <strong class="node">UpdateScore</strong> event to update the displayed score whenever the player hits a target.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.66.png" /></p>
  </blockquote>

  <p>Very nice! The scoreboard is up and running.</p>

  <blockquote class="challenge" id="challenge-3-05-00">
    <h4 id="bonus-challenge">Bonus Challenge:</h4>
    <p>We can add an “arcade” scoring effect if you’re up for a challenge.</p>

    <p>Use a <strong class="node">Spawn Actor from Class</strong> node to spawn a <strong class="blueprint">BP_ScoreAddition</strong> when you hit a target. Once the <strong class="blueprint">BP_ScoreAddition</strong> is spawned, it will handle its own animation and destruction. Make sure to spawn it in the correct location with the correct <b class="variable"><i class="pin in int"></i>Score Addition</b> value.</p>

    <p>You can add a nice sound effect too! Use the <strong class="node">Spawn Sound at Location</strong> node.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.67.png" /></p>
  </blockquote>

  <p>Time to make more complex targets!</p>

  <p class="optional"><span class="hide">&gt; Confused about arrays? <a href="core_3.html"><strong>Click here</strong></a> to learn what they are and how they work. [TODO: array lesson]</span></p>

  <hr />

</div>
<div id="3-color-changing-target" class="scrollspy-section">
  <h2 id="color-changing-target">Color Changing Target</h2>

  <p>Our next target is similar to the basic target in that it explodes and awards points, but this one also randomly changes states between red, green, and gold.</p>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/color_changing_finished.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>Let’s get started by reusing some of our previous work:</p>

  <ul>
    <li>Right-click the <strong class="blueprint">BP_Target</strong> actor in the <strong>Content Browser</strong>.</li>
    <li>Select <strong>Duplicate</strong>.</li>
    <li>Rename the new actor blueprint <strong class="blueprint">BP_Target_ColorChange</strong>.</li>
    <li>Open the new blueprint.</li>
  </ul>

  <p>Let’s start by making the target randomly change colors. To do that, we’re going to need to change the target’s color at random times.</p>

  <ul>
    <li>Create a new custom event called <strong class="node event">ChangeType</strong>.</li>
  </ul>

  <p>Change type is going to work by picking a random number between <strong>0</strong> and <strong>2</strong>. Depending on the number it chooses, it will change the target’s color.</p>

  <ul>
    <li>Place a <strong class="node green">Random Integer in Range</strong> node.</li>
    <li>Give it a <b class="variable">Min<i class="pin out int"></i></b> value of <strong>0</strong> and a <b class="variable">Max<i class="pin out int"></i></b> value of <strong>2</strong>.</li>
    <li>Place a <strong class="node yellow">Switch on Int</strong> node.</li>
    <li>Click the <strong>Add pin</strong> button 3 times. This will add 3 execution pins labeled <strong>0</strong>, <strong>1</strong> and <strong>2</strong>.</li>
    <li><b class="node green">Random Integer in Range<i class="pin out connected int"></i></b><span class="connector int"></span><b class="node yellow"><i class="pin in connected int"></i>Switch on Int</b></li>
  </ul>

  <p><img alt="Switch on Int" class="zoomable" src="../assets/learn_resources/core_3/3.69.png" /></p>

  <p><strong class="node yellow">Switch on Int</strong> works by executing different code depending on the integer that was given to it. In this way, we’ll be able to do different things depending on whether the random number was a <strong>0</strong>, <strong>1</strong>, or <strong>2</strong>.</p>

  <blockquote class="optional">
    <p><strong class="node yellow">Switch</strong> statements can be thought of as a specialized <strong class="node gray">Branch</strong>.</p>
  </blockquote>

  <blockquote class="challenge" id="challenge-3-06-00">
    <h4 id="challenge-6">Challenge:</h4>
    <p>Use the <strong class="node yellow">Switch on Int</strong> outputs to randomly change the target’s color using the <strong class="node">Set Material <i class="detail">(Target)</i></strong> node. Use any of the materials in the <strong>Materials &gt; Targets</strong> folder, or make your own Material Instances based off of them!</p>

    <p>There are a lot of options to play with to personalize your targets. You could even randomize their static meshes using <strong class="node">Set Static Mesh <i class="detail">(Target)</i></strong></p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.70.png" /></p>
  </blockquote>

  <ul>
    <li><b class="node event">BeginPlay<i class="pin execution out"></i></b><span class="connector execution"></span><b class="node "><i class="pin execution in"></i>ChangeType</b></li>
  </ul>

  <p><img alt="BeginPlay -&gt; ChangeType" class="zoomable" src="../assets/learn_resources/core_3/3.72.png" /></p>

  <ul>
    <li>Place multiple <strong class="blueprint">BP_Target_ColorChange</strong> actors in the level.</li>
  </ul>

  <p>When you press play, the targets should randomly start with one of your three materials. Every time you press play, their materials will be different.</p>

  <p>Not only do we need to set the target’s color, but we also need to change its point value. We’ll do this by storing the value in a <strong>variable</strong>. We’ll then be able to use that variable’s data to change the player’s score.</p>

  <ul>
    <li>Create a new <strong class="variable"><i class="pin bar int"></i>Integer</strong> variable named <strong>Value</strong>.</li>
    <li>When the target changes color, update the <strong class="variable"><i class="pin bar int"></i>Value</strong> variable with the proper point value. Make sure the colors and values line up the way you want.</li>
  </ul>

  <p><img alt="Changing the target value along with its color" class="zoomable" src="../assets/learn_resources/core_3/3.71.png" /></p>

  <p>Before we move on to actually interacting with the color changing target, let’s make the target randomly change colors over time. We do this by firing the <strong class="node event">ChangeType</strong> event at random intervals.</p>

  <p>In Lesson 2, we learned how to use looping Timers to call a function over and over again. This works great, but we wouldn’t be able to change the timer’s interval duration. Instead, we want each interval between <strong class="node event">ChangeType</strong>s to be random too. We can achieve this using a <strong class="node">Delay</strong> and then calling <strong class="node">ChangeType</strong> within itself.</p>

  <blockquote class="challenge" id="challenge-3-07-00">
    <h4 id="challenge-7">Challenge:</h4>
    <p>Using a <strong class="node">Delay</strong>, a <strong class="node green">Random Float in Range</strong>, and a <strong class="node">ChangeType</strong> node, set up the <strong class="node event">ChangeType</strong> event to infinitely loop at random intervals.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.73.png" /></p>
  </blockquote>

  <p>Very cool! Now when you press play, your targets will continue to change type over time.</p>

  <p>The last thing we need to do is get the player blueprint communicating with the new type of target.</p>

</div>
<div id="3-blueprint-interfaces" class="scrollspy-section sub-section">
  <h3 id="blueprint-interfaces">Blueprint Interfaces</h3>

  <ul>
    <li>Open <strong class="blueprint">BP_InteractionPlayer</strong></li>
  </ul>

  <p>Our chain of <strong class="node">Cast To…</strong> nodes is about to get really long. In fact, if we continue doing it this way, we’ll have a total of 5 <strong class="node">Cast To…</strong> nodes with all our different types of targets. When code looks like this, with lots of repetition, there is usually a better way.</p>

  <p>So far we’ve done a good job making each actor have a generalized function name called <strong class="node event">Interact</strong>. This allows the <strong class="blueprint">BP_InteractionPlayer</strong> to do what it does best, interact. But we are still checking what type of actor we’re looking at before we can interact with it. The player should be able to interact with <em>everything</em>, then whatever we’re looking at can decide whether or not it should do anything.</p>

  <p>We can do this using a <strong>Blueprint Interface</strong>. Blueprint Interfaces, or <strong>BPI</strong>s, allow us to create types of <strong>messages</strong>. Any blueprint can send these messages to anything else. It’s then up to the receiver to respond to the message or not.</p>

  <ul>
    <li>Go to the <strong>Level Editor</strong>.</li>
    <li>In the <strong>Content Browser</strong> click <strong>Add New</strong> or right-click in empty space.</li>
    <li>Hover the <strong>Blueprints</strong> submenu and select <strong>Blueprint Interface</strong>.</li>
    <li>Name it <strong>BPI_Interaction</strong>.</li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/create_bpi.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <ul>
    <li>Open the new <strong>BPI</strong>.</li>
  </ul>

  <p>This is the <strong>Interface Editor</strong> editor. It only allows you to define function names. These functions are the <strong>messages</strong> mentioned above. We can’t add code in here because it is up to the receiver of the message to know what to do.</p>

  <ul>
    <li>Rename <strong>NewFunction_0</strong> to <strong>Interact</strong>.</li>
  </ul>

  <p>We’re going to add one additional thing in here that we haven’t talked about yet. Currently, the player blueprint assigns value to whatever target it hits. That’s because previously we knew what kind of target we were hitting. Now, all the player will do is send a message to an unknown actor. Therefore, it’s up to the targets to tell the player how much they’re worth. We do that by adding a score <strong>Output</strong> to the BPI’s <strong>Interact</strong> message.</p>

  <ul>
    <li>Add a new <strong>Output</strong> using the <strong>New</strong> button.</li>
    <li>Name it <strong>Score</strong>.</li>
    <li>Set it’s type to <strong class="variable"><i class="pin bar int"></i>Integer</strong>.</li>
    <li><strong>Compile</strong> and <strong>Save</strong>.</li>
  </ul>

  <p><img alt="Interact BPI" class="zoomable" src="../assets/learn_resources/core_3/3.74.png" /></p>

  <p>That’s it! You can close the <strong>Interface Editor</strong>.</p>

</div>
<div id="3-using-our-bpi" class="scrollspy-section sub-section">
  <h3 id="using-our-bpi">Using our BPI</h3>

  <p>Now that we set up a BPI, let’s update all our old code. Don’t worry, it won’t take too long!</p>

  <p>The first thing we have to do is add our new <strong>Interface</strong> to each blueprint. This will allow each actor to receive those types of messages.</p>

  <ul>
    <li>Open <strong>BP_Target</strong>.</li>
    <li>Delete the <strong class="node event">Interact</strong> event node</li>
    <li>Click <strong>Class Settings</strong> in the blueprint <strong>Toolbar</strong>.</li>
    <li>In the <strong>Details</strong> panel, add your new <strong>BPI_Interaction</strong> interface.</li>
    <li><strong>Compile</strong>.</li>
  </ul>

  <p>In the <strong>My Blueprint</strong> panel you’ll see a new tab called <strong>Interfaces</strong> with your <strong>Interact</strong> function underneath.</p>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/add_BPI.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <blockquote class="important">
    <p>If we added a BPI function that didn’t use an output, you’d add it as an Event to the Event Graph. Since ours uses an output, it gets placed in the special <strong>Interface</strong> function area.</p>
  </blockquote>

  <ul>
    <li>Copy all the old Interact code and paste it in the new <strong class="node">Interact</strong> function.</li>
    <li>Connect the code in between <strong class="node purple">Interact</strong> and <strong class="node purple">Return Node</strong></li>
  </ul>

  <p>The <strong class="node purple">Return Node</strong> is new to you, but you’ve probably already assumed what it does. Whatever value you plug into <strong class="variable"><i class="pin in int"></i>Score</strong> is the function’s output.</p>

  <ul>
    <li>Give the <strong class="variable"><i class="pin in int"></i>Score</strong> output a value of <strong>1</strong>.</li>
  </ul>

  <p><img alt="Using Interact BPI in BP_Target" class="zoomable" src="../assets/learn_resources/core_3/3.75.png" /></p>

  <ul>
    <li>Repeat this process for <strong class="blueprint">BP_Target_ColorChange</strong>.
      <ul>
        <li>Don’t forget to <strong>Compile</strong> after adding your interface.</li>
        <li>Make sure to output the blueprint’s <strong class="variable">Value<i class="pin out int"></i></strong> variable because its not a constant number like it is for <strong class="blueprint">BP_Target</strong>.</li>
      </ul>
    </li>
    <li>Your interactions won’t work yet, but they will soon enough!</li>
  </ul>

  <p><img alt="Using Interact BPI in BP_Target_ColorChange" class="zoomable" src="../assets/learn_resources/core_3/3.76.png" /></p>

  <p>Now that all our actors are set up to receive <strong>Interact</strong> messages, let’s send those messages from our <strong class="blueprint">BP_InteractionPlayer</strong>.</p>

  <ul>
    <li>Open the <strong class="blueprint">BP_InteractionPlayer</strong> Event Graph.</li>
  </ul>

  <p>It’s time for some node cleanup!</p>

  <ul>
    <li>Delete all the <strong class="node">Cast To…</strong> and <strong class="node">Interact</strong> nodes.</li>
    <li>Replace them with a single <strong class="node">Interact <i class="detail">(Message)</i></strong> node.</li>
    <li><strong class="variable"><i class="detail">Break Hit Result &gt; </i>Hit Actor<i class="pin out object connected"></i></strong><span class="connector object"></span><strong class="variable"><i class="pin object connected"></i><i class="detail">Interact &gt; </i>Target</strong></li>
    <li>Use the <strong class="variable">Score <i class="pin int out"></i></strong> output as the value you add to your current score.</li>
  </ul>

  <p><img alt="Sending the Interact BPI Message" class="zoomable" src="../assets/learn_resources/core_3/3.77.png" /></p>

  <p>Test it out! Interacting with <strong class="blueprint">BP_InteractionTest</strong> won’t work anymore, but both your <strong class="blueprint">BP_Target</strong> and <strong class="blueprint">BP_Target_ColorChange</strong> interactions will.</p>

  <blockquote class="optional">
    <p>If you want your <strong class="blueprint">BP_InteractionTest</strong> to work, all you have to do is set up the <strong>BPI</strong> the same way we did for the two targets.</p>
  </blockquote>

  <p>Our BPI removes unnecessary code and allows us to create new interact-able actors without opening <strong class="blueprint">BP_InteractionPlayer</strong>. Major win!</p>

  <blockquote class="important">
    <p>In general, <strong>casting</strong> is a great way to communicate between actors. The moment you start casting too much, or see a repeated process, check if you can use a <strong>BPI</strong>.</p>

    <p><span class="hide">Not sure why that was important or how <strong>Blueprint Interfaces</strong> work? <a href="core_3.html" class="blue"><strong>Click here</strong></a> to learn more about them and when to use them.[TODO: more indepth BPI]</span></p>
  </blockquote>

  <hr />

</div>
<div id="3-pop-up-target" class="scrollspy-section">
  <h2 id="pop-up-target">Pop Up Target</h2>

  <p>Here’s what the Pop Up Target looks like:</p>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/pop_up_finished.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <ul>
    <li>Duplicate the <strong class="blueprint">BP_Target</strong>, name it <strong class="blueprint">BP_Target_PopUp</strong></li>
  </ul>

  <p>Since we’re using a <strong>BPI</strong>, our new target is already set up for interaction. If you place one in the world, it will explode when you click on it. The issue is that it currently only behaves like a regular <strong class="blueprint">BP_Target</strong>. Instead, we want to program it to continuously pop up and back down. That way we can hide it behind cover so the player can only hit it at certain times.</p>

  <p>To do this we’re going to use an Unreal Engine tool called <strong>Timeline</strong>.</p>

  <ul>
    <li>Right-click and search <strong>Add Timeline…</strong></li>
    <li>Place the timeline and name it <strong>UpAndDown</strong></li>
  </ul>

  <p><img alt="Timeline and BeginPlay" class="zoomable" src="../assets/learn_resources/core_3/3.78.png" /></p>

  <ul>
    <li>Double-click the new timeline to open up the <strong>Timeline Editor</strong></li>
    <li>Click the <strong>ƒ+</strong> in the upper left corner to add a float track.</li>
    <li>Name it <strong>Data</strong></li>
  </ul>

  <p><img alt="A new float track" class="zoomable" src="../assets/learn_resources/core_3/3.79.png" /></p>

  <p>A <strong>Timeline</strong> allows us to create our own curve using <strong>keyframes</strong>. We then will be able to use that curve in our code by changing our target’s position based on the value of the curve at a certain point in time.</p>

  <p><strong>Keyframes</strong> allow us to define the value of the curve at a certain time. The engine then does the rest to interpret the value in between the keyframes. Let’s do it!</p>

  <ul>
    <li>Hold <kbd>Shift</kbd> and Left-Click anywhere in the curve. You just added a keyframe!</li>
    <li>Select the keyframe and set its <strong>Time</strong> and <strong>Value</strong> to <strong>0</strong></li>
  </ul>

  <p><img alt="Our first keyframe" class="zoomable" src="../assets/learn_resources/core_3/3.80.png" /></p>

  <ul>
    <li>Add another keyframe and set its <strong>Time</strong> and <strong>Value</strong> to <strong>1</strong></li>
    <li>Add a final keyframe and set its <strong>Time</strong> to <strong>5</strong> and its <strong>Value</strong> to <strong>0</strong></li>
  </ul>

  <p><img alt="Final linear curve" class="zoomable" src="../assets/learn_resources/core_3/3.81.png" /></p>

  <p>Great! As you can see, the value of this curve will increase from <strong>0</strong> to <strong>1</strong> in the first second, then slowly decrease from <strong>1</strong> to <strong>0</strong> over the next 4 seconds.</p>

  <p>At this point, the timeline is quite linear. Let’s make the values curve a bit more to give the target’s movement some character.</p>

  <ul>
    <li>Right-click the first keyframe and select <strong>Auto</strong> under the <strong>Key Interpolation</strong> options.</li>
    <li>Do the same for the second keyframe.</li>
  </ul>

  <p><img alt="Curve the Timeline with Key Interpolation" class="zoomable" src="../assets/learn_resources/core_3/3.82.png" /></p>

  <p>Now the timeline actually curves a bit. You can adjust the tangent lines to customize your curve. Feel free to play with the other types of <strong>Key Interpolation</strong>.</p>

  <p>Excellent! We’re done editing the <strong>Timeline</strong> for now, go back to the <strong>Event Graph</strong>.</p>

  <p>You’ll notice a new <strong class="variable">Data <i class="pin out float"></i></strong> output on <strong class="node yellow">UpAndDown</strong>. This will output the value of the curve at any given time.</p>

  <ul>
    <li><b class="node event">BeginPlay<i class="pin execution out"></i></b><span class="connector execution"></span><b class="node yellow"><i class="pin execution in"></i><i class="detail">UpAndDown &gt; </i>Play from Start</b></li>
    <li>For testing purposes, place a <b class="node ">Print String</b></li>
    <li><b class="node yellow"><i class="detail">UpAndDown &gt; </i>Update<i class="pin execution out"></i></b><span class="connector execution"></span><b class="node"><i class="pin execution in"></i>Print String</b></li>
    <li>Print <b class="variable"><i class="detail">UpAndDown &gt; </i>Data <i class="pin out float"></i></b></li>
  </ul>

  <p><img alt="Print the timeline data" class="zoomable" src="../assets/learn_resources/core_3/3.92.png" /></p>

  <p>Let’s test out our timeline.</p>

  <ul>
    <li>Place a single <strong class="blueprint">BP_Target_PopUp</strong> in the level.</li>
    <li>Press <strong>Play</strong> and watch the values printed on the screen.</li>
  </ul>

  <p>When you press <strong>Play</strong>, you should see the values of our curve print from <strong>0</strong> to <strong>1</strong> to <strong>0</strong> for 5 seconds.</p>

  <p>We’re going to use these values to move our target. Value <strong>0</strong> means our target will be at its starting position, and <strong>1</strong> means our target will be at its highest position. The best way to do this is to think of the values between <strong>0</strong> and <strong>1</strong> as <strong>percentages</strong> of a total offset from the target’s origin position. Let’s say our total offset is <strong>20</strong> in the <strong>Z-direction</strong>. This is what the math looks like:</p>

  <script type="math/tex; mode=display">\begin{equation}
  \begin{bmatrix}
    \text{New Location}
  \end{bmatrix}
  =
  \begin{bmatrix}
    \text{Origin}
  \end{bmatrix}
  +
  \begin{bmatrix}
   0 \\
   0 \\
   20
  \end{bmatrix}
  \times
  \text{Timeline Data}
\end{equation}</script>

  <p>Let’s start by storing the target’s origin position.</p>

  <ul>
    <li>Create a new <strong class="variable"><i class="pin bar vector"></i> Vector</strong> variable named <strong>Origin</strong></li>
    <li><strong class="node">Set Origin</strong> equal to the target’s location just before running the timeline</li>
  </ul>

  <p><img alt="Setting the origin position" class="zoomable" src="../assets/learn_resources/core_3/3.83.png" /></p>

  <blockquote class="challenge" id="challenge-3-08-00">
    <h4 id="challenge-8">Challenge:</h4>
    <p>Move the target up and down using the math equation above and the <strong class="node">SetActorLocation</strong> node.</p>

    <p>Test it out to verify that each <strong class="blueprint">BP_Target_PopUp</strong> immediately jumps up and then slowly moves down.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.84.png" /></p>
  </blockquote>

</div>
<div id="3-pop-up-continuously" class="scrollspy-section sub-section">
  <h3 id="pop-up-continuously">Pop Up Continuously</h3>

  <p>As implemented, our pop up targets jump once at level start. Let’s make them jump up and down repeatedly.</p>

  <ul>
    <li>Open the <strong class="node yellow">UpAndDown</strong> timeline again.</li>
    <li>Check the <strong>Loop</strong> option at the top.</li>
  </ul>

  <p>Our looping timeline causes targets to move up and down without pause in between cycles. Let’s create downtime between jumps.</p>

  <ul>
    <li>Change the length of the timeline to <strong>8</strong>.</li>
  </ul>

  <p>Now there is a 3 second pause at the end of the jump.</p>

  <p><img alt="Update the UpAndDown timeline to loop and pause" class="zoomable" src="../assets/learn_resources/core_3/3.85.png" /></p>

  <p>The <b class="blueprint">BP_Target_PopUp</b>s should continuously jump up and down with a brief pause at the bottom.</p>

  <blockquote class="challenge" id="challenge-3-09-00">
    <h4 id="challenge-9">Challenge:</h4>
    <p>Using a <strong class="node">Delay</strong> and a <strong class="node green">Random Float in Range</strong>, make the <strong class="blueprint">BP_Target_PopUp</strong>s randomly start their jumping so they don’t pop up immediately and in unison.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.86.png" /></p>
  </blockquote>

  <p>Wonderful! All our <strong class="blueprint">BP_Target_PopUp</strong>s randomly pop up and down. Go ahead and place some in the level behind obstacles.</p>

  <p>You’ll probably want to add some of your own static mesh obstacles into the scene. A quick way to see all the static meshes in your content browser is to use the <strong>Static Mesh</strong> filter.</p>

  <ul>
    <li>In the <strong>Content Broswer</strong>, open a high level folder like <strong>Content</strong> or <strong>Meshes</strong></li>
    <li>Open the Content Browser’s <strong>Filters</strong> menu</li>
    <li>Select <strong>Static Mesh</strong></li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/filter_meshes.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

</div>
<div id="3-creating-a-new-curve" class="scrollspy-section sub-section">
  <h3 id="creating-a-new-curve">Creating a New Curve</h3>

  <p>We’ve implemented a timeline curve that defines the movement of <strong class="blueprint">BP_Target_PopUp</strong>. If we wanted to create another timeline with the same curve, we’d have to recreate the new curve manually. This isn’t ideal. Fortunately, there is an alternative approach that allows us to reuse and edit curves separately from individual timelines.</p>

  <ul>
    <li>Open <strong>Blueprints &gt; Utility &gt; Curves</strong></li>
  </ul>

  <p>In this folder, you will find a few curves we’ve created for you. Let’s create our own.</p>

  <ul>
    <li>Right click and select <strong>Miscellaneous &gt; Curve</strong></li>
    <li>Select <strong>CurveFloat</strong> in pop up window</li>
    <li>Name the curve “Curve_MyCurve”</li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/create_curve_asset.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <ul>
    <li>Open your new <strong>Curve_MyCurve</strong></li>
  </ul>

  <p>Here we can define our curve just like we did in the timeline editor.</p>

  <ul>
    <li>Create a new curve for your pop up target</li>
  </ul>

  <p><img alt="finished curve" class="zoomable" src="../assets/learn_resources/core_3/finished_curve.png" /></p>

  <ul>
    <li>Save <strong>Curve_MyCurve</strong></li>
    <li>Select <strong>Curve_MyCurve</strong> in the content browser and return to the <strong>UpAndDown</strong> timeline (This part is important)</li>
    <li>Click the button that looks like a curve from the top bar</li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/use_new_curve_timeline.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>Just like that, <strong>Curve_MyCurve</strong> is now imported into our timeline.</p>

  <ul>
    <li>Disconnect <b class="variable"><i class="detail">UpAndDown &gt; </i>Data <i class="pin out float"></i></b></li>
    <li>Connect <b class="variable"><i class="detail">UpAndDown &gt; </i>Curve My Curve <i class="pin out float"></i></b></li>
  </ul>

  <p>Fantastic! <b class="blueprint">BP_Target_PopUp</b> will now move along your custom curve.</p>

  <blockquote class="important">
    <p>Any changes we make to <strong>Curve_MyCurve</strong> in the curve editor will be reflected in all referencing timelines.</p>
  </blockquote>

  <p>Great job! You just learned how to animate with timelines and use external curves to drive those animations. Let’s wrap this target up with a quick challenge:</p>

  <blockquote class="challenge" id="challenge-3-10-00">
    <h4 id="challenge-10">Challenge:</h4>
    <p>Right now the <strong class="blueprint">BP_Target_PopUp</strong>s are worth as many points as regular <strong class="blueprint">BP_Target</strong>s. Make the <strong class="blueprint">BP_Target_PopUp</strong>s worth <strong>5</strong> points rather than <strong>1</strong>. Do this in <strong>BP_Target_PopUp</strong>’s <strong>Interact</strong> interface function.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.87.png" /></p>
  </blockquote>

  <hr />

</div>
<div id="3-wild-target" class="scrollspy-section">
  <h2 id="wild-target">Wild Target</h2>

  <ul>
    <li>Duplicate the <strong class="blueprint">BP_Target</strong>, name it <strong class="blueprint">BP_Target_Wild</strong></li>
  </ul>

  <p>How does our Wild Target differ from the normal target?</p>

  <ul>
    <li>The Wild Target doesn’t disappear</li>
    <li>The Wild Target is worth more points on click</li>
    <li>The Wild Target moves around like crazy!</li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/wild_target_finished.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>Let’s start by taking care of the first two points in the <strong class="blueprint">BP_Target_Wild</strong>’s <strong class="node">Interact</strong> interface function.</p>

  <blockquote class="challenge" id="challenge-3-11-00">
    <h4 id="challenge-11">Challenge:</h4>
    <p>Ensure that a <strong class="blueprint">BP_Target_Wild</strong> does not disappear on click, and is worth <strong>3</strong> points.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.88.png" /></p>
  </blockquote>

  <ul>
    <li>Place a <strong class="blueprint">BP_Target_Wild</strong> in the level where it can be seen from the start point.</li>
  </ul>

  <p>Test it out to make sure it works. Press <strong>Play</strong> and click on the stationary Wild Target. It shouldn’t disappear and you should get points.</p>

  <p>Great stuff. We want the wild target to start hidden from view, then come into view as a target for a short time.</p>

  <ul>
    <li>Move the <b class="blueprint">BP_Target_Wild</b> somewhere in the level where is can not be seen from the start point.</li>
  </ul>

  <p>Now let’s animate that target!</p>

</div>
<div id="3-matinee" class="scrollspy-section sub-section">
  <h3 id="matinee">Matinee</h3>

  <p><strong>Matinee</strong> is UE4’s powerful scene animation tool. It allows you to easily create in-game cinematics and dynamic gameplay using keyframes similar to <strong>Timeline</strong>. We’re going to use it to move the wild target all over the shooting gallery.</p>

  <ul>
    <li>Click <strong>Cinematics</strong> on the Level Editor’s <strong>Toolbar</strong></li>
    <li>Select <strong>Add Matinee</strong>.</li>
  </ul>

  <p>The <strong>Matinee Editor</strong> opens automatically. We’ll be spending most our time in the <strong>Tracks</strong> panel of this editor.</p>

  <p><img alt="Matinee Editor" class="zoomable" src="../assets/learn_resources/core_3/3.89.png" /></p>

  <ul>
    <li>Right-click in the blank area in the left of the <strong>Tracks</strong> panel.</li>
    <li>Select <strong>Add New Empty Group</strong></li>
    <li>Name it <strong>Target</strong></li>
  </ul>

  <p>We just created a new animation group. It’s called a <strong>Group</strong> because we can add many actors to it. Every actor in the group will be effected by the animations we define in it.</p>

  <ul>
    <li>Select the <strong class="blueprint">BP_Target_Wild</strong> in the Level Editor <strong>Viewport</strong> or <strong>World Outliner</strong>.</li>
    <li>With the actor selected, go back to the <strong>Matinee Editor</strong> and right-click the <strong>Target</strong> Animation Group.</li>
    <li>Select <strong>Actors &gt; Add Selected Actors</strong></li>
  </ul>

  <p>The Wild Target is now a part of the Animation Group! We can test that we did it right by selecting the <strong>Target</strong> track. When we do, the target in the world should become selected.</p>

  <ul>
    <li>Go to the <strong>Matinee</strong> editor and right-click the <strong>Target</strong> Animation Group.</li>
    <li>Select <strong>Add New Movement Track</strong>.</li>
  </ul>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/add_matinee.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>We’re ready to start creating animation keyframes. <strong>Matinee</strong> automatically places a keyframe at the start, its marked with a small red triangle.</p>

  <ul>
    <li>Move the scrubber to the 2.5 second mark.</li>
    <li>Press the <kbd>Enter</kbd> key.</li>
  </ul>

  <p>You just placed a new keyframe. You may also notice the red recording icon in the lower left of the screen. That means that where ever you move the <strong>Wild Target</strong>, its position will be the value of the keyframe.</p>

  <p><img alt="Recording a new keyframe" class="zoomable" src="../assets/learn_resources/core_3/3.90.png" /></p>

  <ul>
    <li>In your level, move the <strong>Wild Target</strong> out into the open. A trail will follow it showing the path that the target will make when animating.</li>
  </ul>

  <p>Now if you drag your scrubber between the two keyframes, you should see the <strong>Wild Target</strong> move between the two points.</p>

  <video controls="" loop="" class="not-zoomable">
  <source src="../assets/learn_resources/core_3/matinee_keyframed_movement.mp4" type="video/mp4" />
  Your browser does not support HTML5 video.
</video>

  <p>Excellent! Add as many keyframes as you want. Feel free to make the matinee longer too. Do this by moving the small red scrubber at the end of the <strong>Matinee</strong> timeline. When you’re done with your <strong>Matinee</strong> animation, move on to learn how to trigger it.</p>

</div>
<div id="3-triggering-our-matinee" class="scrollspy-section sub-section">
  <h3 id="triggering-our-matinee">Triggering our Matinee</h3>

  <p>First, to test our Matinee, let’s play it when the game starts.</p>

  <ul>
    <li>Close the Matinee if you haven’t already.</li>
    <li>Click on the new <strong>Matinee Actor</strong> in the <strong>World Outliner</strong>.
      <ul>
        <li>Check the <strong>Play on Level Load</strong> option in the details panel.</li>
        <li><em>Notice all the other options here for future use.</em></li>
      </ul>
    </li>
  </ul>

  <p>Test it out! Your target should fly all over the world when you press <strong>Play</strong>.</p>

  <p>Now, lets set it up so the Matinee starts after a delay. We’ll do this using the Level Blueprint.</p>

  <ul>
    <li>Uncheck the <strong>Play on Level Load</strong> option in the details panel.</li>
    <li>Open up the Level Blueprint by clicking <strong>Blueprints &gt; Open Level Blueprint</strong> in the <strong>Toolbar</strong>.</li>
    <li>With your <strong>MatineeActor</strong> selected in the <strong>Level Editor</strong>, right-click and <strong>Create a Reference to MatineeActor</strong>. You can also click and drag from the <strong>World Outliner</strong> into the Level Blueprint.</li>
    <li>Drag a wire from <strong class="variable">Matinee Actor <i class="pin object"></i></strong> and place a <strong class="node">Play</strong> node.</li>
  </ul>

  <blockquote class="challenge" id="challenge-3-12-00">
    <h4 id="challenge-12">Challenge:</h4>
    <p>Using the <strong class="node event">BeginPlay</strong> event and a <strong class="node">Delay</strong> node, play the Matinee after <strong>30</strong> seconds.</p>

    <p><img alt="Challenge Answer" class="zoomable" src="../assets/learn_resources/core_3/3.91.png" /></p>
  </blockquote>

  <p>Woo! Now we have a crazy target that comes in after 30 seconds, giving the player a quick chance to rack up as many points as possible.</p>

  <p>Go ahead and <strong>Play</strong> you experience. Have fun!</p>

  <hr />

</div>
<div id="3-conclusion" class="scrollspy-section">
  <h2 id="conclusion">Conclusion</h2>

  <p>Wow! We’ve covered a lot of material in this lesson:</p>

  <ul>
    <li>Blueprint Communication
      <ul>
        <li>Creating <strong>Custom Events</strong>.</li>
        <li>Using <strong>Cast To</strong> nodes to fire events on other actors.</li>
        <li>Using <strong>Blueprint Interfaces</strong> when you find a common interaction between multiple blueprints.</li>
      </ul>
    </li>
    <li>Creating custom curves with <strong>Timeline</strong></li>
    <li>Animating actor properties with <strong>Matinee</strong></li>
  </ul>

</div>

    </div>

  </div>
</div>

        <div class="small-12 small-centered columns">
  <div class="default-panel margin-bottom shadow">

   <div class="header shadow-down more-padding">
      <h4>Project 3 - Getting Creative</h4>
    </div>
    <div class="content more-padding light-background reader">
      <div id="3-getting-creative" class="scrollspy-section">
  <h2 class="hide" id="your-interactive-experience">Your Interactive Experience</h2>

  <p>In this assignment, you’ll invent ways to interact in a level of your own design. The experience should allow the player to “touch” the environment with gaze and simple input.</p>

  <ul>
    <li><strong>Create <em>at least</em> two new interactable actors that respond to player trace</strong></li>
    <li><strong>Build a new level that meaningfully incorporates your interactable actors</strong></li>
  </ul>

  <p>Trace communication is an extremely versatile tool. We expect you to submit a project that applies lesson techniques in a new way- <strong>don’t build another shooting gallery.</strong></p>

</div>
<div id="3-have-fun" class="scrollspy-section sub-section">

  <h4 id="getting-started">Getting started</h4>

  <p>You might discover an interesting interaction technique by experimentation. Or you could start with an activity and setting before devising specific game mechanics. Consider the following questions as you get started:</p>

  <ul>
    <li>Should the player discover interactivity by experimentation, or does the level provide direction?</li>
    <li>Do interactable actors also interact with eachother?</li>
    <li>Is the experience open-ended, or does it have a distinct beginning and end?</li>
  </ul>

  <h4 id="creating-a-seated-experience">Creating a seated experience</h4>

  <p>As you build your level, keep in mind that the player should be constrained to a single location.</p>

  <p>We experimented with scale and the “desktop” in the shooting gallery, but don’t feel obligated to continue in this direction.</p>

</div>

    </div>

  </div>
</div>

      </div>
    </div>

  </div>


    <div class="bottom-spacer"></div>
  </body>
</html>
